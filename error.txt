Run python -m pytest tests/unit --cov=src --cov-report=xml --cov-report=html
============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-8.4.2, pluggy-1.6.0
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: /home/runner/work/Medical-Text-Classifier/Medical-Text-Classifier
configfile: pytest.ini
plugins: anyio-4.11.0, html-4.1.1, timeout-2.4.0, asyncio-1.2.0, Faker-37.11.0, benchmark-5.1.0, cov-7.0.0, json-report-1.5.0, env-1.2.0, xdist-3.8.0, mock-3.15.1, metadata-3.1.1, postgresql-7.0.2
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 48 items

tests/unit/test_database.py ...........                                  [ 22%]
tests/unit/test_inference.py .........F.....FFF                          [ 60%]
tests/unit/test_models.py ....F..............                            [100%]

=================================== FAILURES ===================================
_______ TestMedicalTextClassifier.test_predict_probability_distribution ________

self = <tests.unit.test_inference.TestMedicalTextClassifier object at 0x7fc89fde5490>

    @pytest.mark.unit
    def test_predict_probability_distribution(self):
        """Test that prediction returns proper probability distribution."""
        classifier = MedicalTextClassifier()
    
        text = "Heart attack symptoms"
        predicted_class, confidence, probabilities = classifier.predict(text)
    
        # Check all focus groups are present
        for group in classifier.focus_group_names:
            assert group in probabilities
    
        # Check probabilities are normalized
        total_prob = sum(probabilities.values())
        assert abs(total_prob - 1.0) < 0.01
    
        # Check probabilities are sorted in descending order
        prob_values = list(probabilities.values())
>       assert prob_values == sorted(prob_values, reverse=True)
E       assert [0.0499999999...9999999999999] == [0.8, 0.04999...9999999999999]
E         
E         At index 0 diff: 0.04999999999999999 != 0.8
E         
E         Full diff:
E           [
E         +     0.04999999999999999,
E               0.8,
E               0.04999999999999999,
E               0.04999999999999999,
E               0.04999999999999999,
E         -     0.04999999999999999,
E           ]

tests/unit/test_inference.py:184: AssertionError
______________ TestClassifierModelLoading.test_load_model_success ______________

args = (<tests.unit.test_inference.TestClassifierModelLoading object at 0x7fc89fde4490>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.api.inference.AutoModelForSequenceClassification'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api.inference' has no attribute 'AutoModelForSequenceClassification'

/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/pkgutil.py:715: AttributeError
__________ TestClassifierModelLoading.test_load_model_file_not_found ___________

self = <tests.unit.test_inference.TestClassifierModelLoading object at 0x7fc89fdd6c10>
mock_exists = <MagicMock name='exists' id='140499653013328'>

    @pytest.mark.unit
    @patch('os.path.exists')
    def test_load_model_file_not_found(self, mock_exists):
        """Test model loading when files don't exist."""
        mock_exists.return_value = False
    
        classifier = MedicalTextClassifier()
    
>       with pytest.raises(FileNotFoundError):
E       Failed: DID NOT RAISE <class 'FileNotFoundError'>

tests/unit/test_inference.py:291: Failed
----------------------------- Captured stderr call -----------------------------
2025-10-22 15:52:14,922 - src.api.inference - INFO - Model not found, using rule-based classification as fallback
------------------------------ Captured log call -------------------------------
INFO     src.api.inference:inference.py:109 Model not found, using rule-based classification as fallback
________ TestClassifierModelLoading.test_load_model_exception_handling _________

args = (<tests.unit.test_inference.TestClassifierModelLoading object at 0x7fc89fde7f10>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.api.inference.joblib'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'src.api.inference' has no attribute 'joblib'

/opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/pkgutil.py:715: AttributeError
_______________ TestPredictionRequest.test_whitespace_only_text ________________

self = <tests.unit.test_models.TestPredictionRequest object at 0x7fc89fd92250>

    @pytest.mark.unit
    def test_whitespace_only_text(self):
        """Test that whitespace-only text is valid (will be handled by API logic)."""
>       request = PredictionRequest(text="   ")
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for PredictionRequest
E       text
E         Value error, Text cannot be empty or only whitespace [type=value_error, input_value='   ', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.12/v/value_error

tests/unit/test_models.py:58: ValidationError
=============================== warnings summary ===============================
../../../../../opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/passlib/utils/__init__.py:854
  /opt/hostedtoolcache/Python/3.11.13/x64/lib/python3.11/site-packages/passlib/utils/__init__.py:854: DeprecationWarning: 'crypt' is deprecated and slated for removal in Python 3.13
    from crypt import crypt as _crypt

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
_______________ coverage: platform linux, python 3.11.13-final-0 _______________

Coverage HTML written to dir htmlcov
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/unit/test_inference.py::TestMedicalTextClassifier::test_predict_probability_distribution - assert [0.0499999999...9999999999999] == [0.8, 0.04999...9999999999999]
  
  At index 0 diff: 0.04999999999999999 != 0.8
  
  Full diff:
    [
  +     0.04999999999999999,
        0.8,
        0.04999999999999999,
        0.04999999999999999,
        0.04999999999999999,
  -     0.04999999999999999,
    ]
FAILED tests/unit/test_inference.py::TestClassifierModelLoading::test_load_model_success - AttributeError: module 'src.api.inference' has no attribute 'AutoModelForSequenceClassification'
FAILED tests/unit/test_inference.py::TestClassifierModelLoading::test_load_model_file_not_found - Failed: DID NOT RAISE <class 'FileNotFoundError'>
FAILED tests/unit/test_inference.py::TestClassifierModelLoading::test_load_model_exception_handling - AttributeError: module 'src.api.inference' has no attribute 'joblib'
FAILED tests/unit/test_models.py::TestPredictionRequest::test_whitespace_only_text - pydantic_core._pydantic_core.ValidationError: 1 validation error for PredictionRequest
text
  Value error, Text cannot be empty or only whitespace [type=value_error, input_value='   ', input_type=str]
    For further information visit https://errors.pydantic.dev/2.12/v/value_error
=================== 5 failed, 43 passed, 1 warning in 1.14s ====================
Error: Process completed with exit code 1.